
# 4 迭代器与生成器相关话题

## 4.1 如何实现可迭代对象和迭代器对象

**实际案例**

如某软件要求，从网络抓取个城市气温信息，并依次显示：
北京: 15~20
天津: 17~22
长春: 12~18
.......

如果依次抓取所有城市气温再显示，显示第一个城市气温时，有很高的延时，并且浪费存储空间，我们期望以"用时访问"的策略，并且能把所有城市气温封装到一个对象里，可用for语句进行迭代，如何解决。

**解决方案**

Step1: 首先第一步实现一个迭代器对象WeatherIterator,在其\_\_next\_\_方法中，每次通过网络API获得一个城市的气温信息，然后返回给用户
Step2: 再实现一个可迭代对象WeatherIterable,在其\_\_iter\_\_方法中返回上面的WeatherIterator对象。对于用户来说只需要使用WeatherIterable对象来创建实例，然后进行迭代。这个类对用户是透明的。

## 4.2 如何使用生成器函数实现可迭代对象

**实际案例**

假设实现一个可迭代对象的类，它能迭代出给定范围内所有素数：

pn = PrimeNumbers(1,30)
for k in pn:
    print(k)

输出结果：
2 3 5 7 11 13 17 19 23 29

**解决方案**

将该类的\_\_iter\_\_方法实现成生成器函数，每次yield返回一个素数
使用生成器对象的好处是可以自动维护迭代状态

## 4.3 如何进行反向迭代以及如何实现反向反向迭代

**实际案例**

实现一个连续浮点数发生器FloatRange(和range类似),根据给定范围(start,end)和步进值(step)产生一些连续浮点数，如迭代FloatRnage(3.0,4.0,.02)可产生序列：
正向:3.0->3.2->3.4->3.6->3.8->4.0
反向:4.0->3.8->3.6->3.4->3.2->3.0

**解决方案**

对于正向迭代，实现\_\_iter\_\_.
对于反向迭代协议，实现\_\_reversed\_\_方法，它返回一个反向迭代器
