
# 4 迭代器与生成器相关话题

## 4.1 如何实现可迭代对象和迭代器对象

**实际案例**

如某软件要求，从网络抓取个城市气温信息，并依次显示：
北京: 15~20
天津: 17~22
长春: 12~18
.......

如果依次抓取所有城市气温再显示，显示第一个城市气温时，有很高的延时，并且浪费存储空间，我们期望以"用时访问"的策略，并且能把所有城市气温封装到一个对象里，可用for语句进行迭代，如何解决。

**解决方案**

Step1: 首先第一步实现一个迭代器对象WeatherIterator,在其\_\_next\_\_方法中，每次通过网络API获得一个城市的气温信息，然后返回给用户
Step2: 再实现一个可迭代对象WeatherIterable,在其\_\_iter\_\_方法中返回上面的WeatherIterator对象。对于用户来说只需要使用WeatherIterable对象来创建实例，然后进行迭代。这个类对用户是透明的。

## 4.2 如何使用生成器函数实现可迭代对象

**实际案例**

假设实现一个可迭代对象的类，它能迭代出给定范围内所有素数：

pn = PrimeNumbers(1,30)
for k in pn:
    print(k)

输出结果：
2 3 5 7 11 13 17 19 23 29

**解决方案**

将该类的\_\_iter\_\_方法实现成生成器函数，每次yield返回一个素数
使用生成器对象的好处是可以自动维护迭代状态

## 4.3 如何进行反向迭代以及如何实现反向反向迭代

**实际案例**

实现一个连续浮点数发生器FloatRange(和range类似),根据给定范围(start,end)和步进值(step)产生一些连续浮点数，如迭代FloatRnage(3.0,4.0,.02)可产生序列：
正向:3.0->3.2->3.4->3.6->3.8->4.0
反向:4.0->3.8->3.6->3.4->3.2->3.0

**解决方案**

对于正向迭代，实现\_\_iter\_\_.
对于反向迭代协议，实现\_\_reversed\_\_方法，它返回一个反向迭代器

## 4.4 如何对可迭代对象做切片操作

**实际案例**

有某个文本文件，想读取其中某范围内的内容如100~300行之间的内容，Python中文件是可迭代对象，是否可以使用类似列表切片的方式得到一个100~300行文件内容的生成器？

f = open('/var/log/dpkg')
for line in f[100:300]: # 可以么？
    ....

**解决方案**

切片的实质：l[2:8:2] 等价于 l.\_\_getitem\_\_(slice(2,8,2)).
使用itertools.islice，它能返回一个迭代对象切片的生成器.

## 4.5 如何在一个for语句中迭代多个可迭代对象

**实际案例**

1 (并行)某版学生期末考试成绩，语文，数学，英语分别存储在3个列表中，同时迭代三个列表，计算每个学生的总分。

2 (串行)某年级有4个班，某次考试每班英语成绩分别存储在4个列表中，依次迭代每个列表，统计全学年成绩高于90分人数。

**解决方案**

1 并行：使用内置函数zip，它能将多个可迭代对象合并，每次迭代返回一个元组。

2 串行：使用标准库中的itertools.chain,它能将多个可迭代对象连接
