
# 9 装饰器相关话题

## 9.1 如何使用函数装饰器

**实际案例**

某些时候我们想为多个函数，统一添加某种功能，比如计时统计，记录日志，缓存运算结构等等。

我们不想在每个函数内一一添加完全相同的代码，如何解决？

**解决方案**

定义装饰器函数，用它来生成一个在原函数基础添加新功能的函数，代替原函数

## 9.2 如何为被装饰的函数保存元数据

**实际案例**

在函数对象中保存这一些函数的元数据，如：

f.\_\_name\_\_: 函数的名字
f.\_\_doc\_\_: 函数文档字符串
f.\_\_module\_\_: 函数所属模块名
f.\_\_dict\_\_: 属性字典
f.\_\_defaults\_\_: 默认参数元组
......

我们在使用装饰器后，再访问上面这些属性访问时，看到的是内部包裹函数的元数据，原来函数的元数据便丢失了，如何解决？

**解决方案**

使用标准库functools中的装饰器wraps装饰内部包裹函数，可以制定将原函数的某些属性，更新到包裹函数上面

## 9.3 如何定义带参数的装饰器

**实际案例**

实现一个装饰器，用它来检查被装饰函数的参数类型。装饰器可以通过参数致命参数的类型，调用时如果检测出类型不匹配则跑出异常。

@type_assert(str,int,int)
def f(a, b, c):
    ......

@type_assert(y=list)
def g(x, y):
    .......
带参数的装饰器就是生产装饰器的工厂

**解决方案**

- 提取函数签名：inspect.signature()
- 带参数的装饰器，也就是根据参数定制化一个装饰器。可以看成生成装饰器的工厂，每次调用type__assert，返回一个特定的装饰器，然后用它去修饰其他函数。


