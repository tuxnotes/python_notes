
# 2 数据结构相关话题

## 2.1 如何在列表，字典，集合中筛选数据

在实际的编程过程中经常遇到这类问题，比如过滤列表中的负数；列出字典{'LiLei': 79,'Jim': 88, 'Lucy': 92}中高于90的项；列出集合中能被3整除的数。对于这类问题，通用的方法是使用for循环，加上if判断.但这种方法效率可能会比较低，在python中可以使用如下解决方案：

- 列表

  - 列表解析: [x for x in data if x >=0 ] recommanded
  - fliter函数: filter(lambda x: x >= 0, data)

- 字典

  - 字典解析: {k:v for k,v in d.items() if v > 90}

- 集合

  - 集合解析: {x for x in s if x % 3 == 0}

## 2.2 如何为元组中的每个元素命名，提高程序可读性

**实际案例**

对于格式固定的数据，通常使用元组来存储，如学生信息系统中数据为
固定格式:(名字，年龄，性别，邮箱)

('Jim',16,'male','jim8721@gmail.com')
('LiLei',17,'male','lilei@qq.com')
('Lucy',16,'female','lucy123@yahoo.com')

使用元组的优势就是存储相同的数据比使用字典节省空间
缺点之一是访问元组中的数据时，需要索引，降低程序可读性

解决方案：

- 方案一：定义一系列数值常量或枚举类型

- 方案二：使用标准库中collections.namedtuple代替内置tuple

## 2.3 如何根据字典中值的大小，对字典排序

**实际案例**

某班英语成绩以字典形式存储为：

{
    'LiLei':79,
    'Jim': 88,
    'Lucy':92,
    ...
}

如何根据成绩高低，计算学生排名

**解决方案**

将字典总各项转换为元组，使用内置函数sorted排序。sorted函数用C实现，且做了大量优化，但不能直接对字典进行排序，需要转化为元组。
元组比较大小的规则：如果第0个索引的值能分出大小，则剩下的元素则不在比较，若第0个索引位置的元素相同，则继续比较索引为1的元素。

方案1：将字典中的项转化为(值，键)元组。(列表解析或元组)

方案2：d.items()返回一个列表，列表中元素是(key,value)的元组，直接对此列表排序，但需要在sorted函数中设置key

sorted(d.items(), key=lambda item: item[1], reverse=True)


